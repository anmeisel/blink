import {
  require_react
} from "./chunk-BZ5DSBWL.js";
import {
  __toESM
} from "./chunk-GFT2G5UO.js";

// node_modules/react-async-hook/dist/react-async-hook.esm.js
var import_react = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }
  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }
  return finalizer(false, value);
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var useGetter = function useGetter2(t) {
  var ref = (0, import_react.useRef)(t);
  useIsomorphicLayoutEffect(function() {
    ref.current = t;
  });
  return (0, import_react.useCallback)(function() {
    return ref.current;
  }, [ref]);
};
var InitialAsyncState = {
  status: "not-requested",
  loading: false,
  result: void 0,
  error: void 0
};
var InitialAsyncLoadingState = {
  status: "loading",
  loading: true,
  result: void 0,
  error: void 0
};
var defaultSetLoading = function defaultSetLoading2(_asyncState) {
  return InitialAsyncLoadingState;
};
var defaultSetResult = function defaultSetResult2(result, _asyncState) {
  return {
    status: "success",
    loading: false,
    result,
    error: void 0
  };
};
var defaultSetError = function defaultSetError2(error, _asyncState) {
  return {
    status: "error",
    loading: false,
    result: void 0,
    error
  };
};
var noop = function noop2() {
};
var DefaultOptions = {
  initialState: function initialState(options) {
    return options && options.executeOnMount ? InitialAsyncLoadingState : InitialAsyncState;
  },
  executeOnMount: true,
  executeOnUpdate: true,
  setLoading: defaultSetLoading,
  setResult: defaultSetResult,
  setError: defaultSetError,
  onSuccess: noop,
  onError: noop
};
var normalizeOptions = function normalizeOptions2(options) {
  return _extends({}, DefaultOptions, {}, options);
};
var useAsyncState = function useAsyncState2(options) {
  var _useState = (0, import_react.useState)(function() {
    return options.initialState(options);
  }), value2 = _useState[0], setValue = _useState[1];
  var reset = (0, import_react.useCallback)(function() {
    return setValue(options.initialState(options));
  }, [setValue, options]);
  var setLoading = (0, import_react.useCallback)(function() {
    return setValue(options.setLoading(value2));
  }, [value2, setValue]);
  var setResult = (0, import_react.useCallback)(function(result) {
    return setValue(options.setResult(result, value2));
  }, [value2, setValue]);
  var setError = (0, import_react.useCallback)(function(error) {
    return setValue(options.setError(error, value2));
  }, [value2, setValue]);
  var merge = (0, import_react.useCallback)(function(state) {
    return setValue(_extends({}, value2, {}, state));
  }, [value2, setValue]);
  return {
    value: value2,
    set: setValue,
    merge,
    reset,
    setLoading,
    setResult,
    setError
  };
};
var useIsMounted = function useIsMounted2() {
  var ref = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    ref.current = true;
    return function() {
      ref.current = false;
    };
  }, []);
  return function() {
    return ref.current;
  };
};
var useCurrentPromise = function useCurrentPromise2() {
  var ref = (0, import_react.useRef)(null);
  return {
    set: function set(promise) {
      return ref.current = promise;
    },
    get: function get() {
      return ref.current;
    },
    is: function is(promise) {
      return ref.current === promise;
    }
  };
};
var useAsyncInternal = function useAsyncInternal2(asyncFunction, params, options) {
  !params && (params = []);
  var normalizedOptions = normalizeOptions(options);
  var _useState2 = (0, import_react.useState)(null), currentParams = _useState2[0], setCurrentParams = _useState2[1];
  var AsyncState = useAsyncState(normalizedOptions);
  var isMounted = useIsMounted();
  var CurrentPromise = useCurrentPromise();
  var shouldHandlePromise = function shouldHandlePromise2(p) {
    return isMounted() && CurrentPromise.is(p);
  };
  var executeAsyncOperation = function executeAsyncOperation2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var promise = function() {
      try {
        return Promise.resolve(asyncFunction.apply(void 0, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }();
    setCurrentParams(args);
    CurrentPromise.set(promise);
    AsyncState.setLoading();
    promise.then(function(result) {
      if (shouldHandlePromise(promise)) {
        AsyncState.setResult(result);
      }
      normalizedOptions.onSuccess(result, {
        isCurrent: function isCurrent() {
          return CurrentPromise.is(promise);
        }
      });
    }, function(error) {
      if (shouldHandlePromise(promise)) {
        AsyncState.setError(error);
      }
      normalizedOptions.onError(error, {
        isCurrent: function isCurrent() {
          return CurrentPromise.is(promise);
        }
      });
    });
    return promise;
  };
  var getLatestExecuteAsyncOperation = useGetter(executeAsyncOperation);
  var executeAsyncOperationMemo = (0, import_react.useCallback)(function() {
    return getLatestExecuteAsyncOperation().apply(void 0, arguments);
  }, [getLatestExecuteAsyncOperation]);
  var isMounting = !isMounted();
  (0, import_react.useEffect)(function() {
    var execute = function execute2() {
      return getLatestExecuteAsyncOperation().apply(void 0, params);
    };
    isMounting && normalizedOptions.executeOnMount && execute();
    !isMounting && normalizedOptions.executeOnUpdate && execute();
  }, params);
  return _extends({}, AsyncState.value, {
    set: AsyncState.set,
    merge: AsyncState.merge,
    reset: AsyncState.reset,
    execute: executeAsyncOperationMemo,
    currentPromise: CurrentPromise.get(),
    currentParams
  });
};
function useAsync(asyncFunction, params, options) {
  return useAsyncInternal(asyncFunction, params, options);
}
var useAsyncAbortable = function useAsyncAbortable2(asyncFunction, params, options) {
  var abortControllerRef = (0, import_react.useRef)();
  var asyncFunctionWrapper = function asyncFunctionWrapper2() {
    for (var _len2 = arguments.length, p = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      p[_key2] = arguments[_key2];
    }
    try {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      var abortController = new AbortController();
      abortControllerRef.current = abortController;
      return Promise.resolve(_finallyRethrows(function() {
        return Promise.resolve(asyncFunction.apply(void 0, [abortController.signal].concat(p)));
      }, function(_wasThrown, _result) {
        if (abortControllerRef.current === abortController) {
          abortControllerRef.current = void 0;
        }
        if (_wasThrown)
          throw _result;
        return _result;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return useAsync(asyncFunctionWrapper, params, options);
};
var useAsyncCallback = function useAsyncCallback2(asyncFunction, options) {
  return useAsyncInternal(
    asyncFunction,
    // Hacky but in such case we don't need the params,
    // because async function is only executed manually
    [],
    _extends({}, options, {
      executeOnMount: false,
      executeOnUpdate: false
    })
  );
};
export {
  useAsync,
  useAsyncAbortable,
  useAsyncCallback
};
//# sourceMappingURL=react-async-hook.js.map
